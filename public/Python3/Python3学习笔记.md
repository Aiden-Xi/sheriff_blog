1. 需要特别注意的事项： 缩进格式一定要标准，因为缩进格式不对，会报错。
``` IndentationError: unindent does not match any outer indentation level ```

2. 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r"this is a line with \n" 则\n会显示，并不是换行

3. 模板和函数的导入
    ```
    在 python 用 import 或者 from...import 来导入相应的模块。
    
    将整个模块(somemodule)导入，格式为： import somemodule
    
    从某个模块中导入某个函数,格式为： from somemodule import somefunction
    
    从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc
    
    将某个模块中的全部函数导入，格式为： from somemodule import *
    ```

4. 可以使用 ``` __doc__获取方法的文档。比如： 获取max方法的文档注释说明   max.__doc__ ```

5. 标准数据类型： 
    - Number（数字）： Python3 支持 int、float、bool、complex（复数）。
    - String（字符串）
    - List（列表）
    - Sets （集合）
    - Tuple （元组）
    - Dictionary （字典）
    
    注意事项：
    - 不可变数据类型（4个）： Number、 String、Sets、Tuple
    - 可变数据类型（2个）：List、Dictionary
    
6. 可以使用type() 和 isinstance() 判断变量类型
    ```
    注意事项：
    注意：在 Python2 中是没有布尔型的，它用数字 0 表示 False，
    用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，
    但它们的值还是 1 和 0，它们可以和数字相加。
    
    isinstance 和 type 的区别在于：
    
    class A:
        pass
    
    class B(A):
        pass
    
    isinstance(A(), A)  # returns True
    type(A()) == A      # returns True
    isinstance(B(), A)    # returns True
    type(B()) == A        # returns False
    区别就是:
    
    type()不会认为子类是一种父类类型。
    isinstance()会认为子类是一种父类类型。

    ```
    
7. 字符串
    - 索引值以 0 为开始值，-1 为从末尾的开始位置。
    - 加号 (+) 是字符串的连接符， 星号 (*) 表示复制当前字符串，紧跟的数字为复制的次数。实例如下：
        ```
        str = 'Runoob'
         
        print (str)          # 输出字符串
        print (str[0:-1])    # 输出第一个到倒数第二个的所有字符
        print (str[0])       # 输出字符串第一个字符
        print (str[2:5])     # 输出从第三个开始到第五个的字符
        print (str[2:])      # 输出从第三个开始的后的所有字符
        print (str * 2)      # 输出字符串两次
        print (str + "TEST") # 连接字符串
        ```
    - 可以在字符串前面添加一个 r，表示原始字符串 ``` print(r'Rub\noob')  => Rub\noob ```
    - 与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] = 'm'会导致错误。
    ```
    注意：
    1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。
    2、字符串可以用+运算符连接在一起，用*运算符重复。
    3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。
    4、Python中的字符串不能改变。
    ```    

8. 列表 （List）
    ```
    注意：
    
    1、List写在方括号之间，元素用逗号隔开。
    2、和字符串一样，list可以被索引和切片。
    3、List可以使用+操作符进行拼接。
    4、List中的元素是可以改变的。
    ```

9. Tuple（元组）
   元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。
   
   元组中的元素类型也可以不相同：
   ```
    注意：
    
    1、与字符串一样，元组的元素不能修改。
    2、元组也可以被索引和切片，方法一样。
    3、注意构造包含0或1个元素的元组的特殊语法规则。
    tup1 = ()    # 空元组
    tup2 = (20,) # 一个元素，（重要重要） 需要在元素后添加逗号
    4、元组也可以使用+操作符进行拼接。
    ```

10. Set（集合）

    集合（set）是一个无序不重复元素的序列。
    
    基本功能是进行成员关系测试和删除重复元素。
    
    可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。
    ```
    # set可以进行集合运算
    a = set('abracadabra')
    b = set('alacazam')
     
    print(a)
     
    print(a - b)     # a和b的差集
     
    print(a | b)     # a和b的并集
     
    print(a & b)     # a和b的交集
     
    print(a ^ b)     # a和b中不同时存在的元素
    ```
    
11. Dictionary（字典）
    字典（dictionary）是Python中另一个非常有用的内置数据类型。
    
    列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。
    
    字典是一种映射类型，字典用"{ }"标识，它是一个无序的键(key) : 值(value)对集合。
    
    键(key)必须使用不可变类型。
    
    在同一个字典中，键(key)必须是唯一的。
    
12. [Python3 运算符](http://www.runoob.com/python3/python3-basic-operators.html)
    注意事项： is 与 == 的区别在于： is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。
    ```
        >>>a = [1, 2, 3]
        >>> b = a
        >>> b is a 
        True
        >>> b == a
        True
        // 这里a[:]返回的是一个新的数组 所以使用is判断的时候返回false的值。
        >>> b = a[:]
        >>> b is a
        False
        >>> b == a
        True
    ```

13. 数字（Number）
    - 符号 '//' 得到的并一定是整数类型的数，它跟分母分子的数据类型有关。
    ``` 
    7 // 2 => 3
    
    7.0 // 2 => 3.0 
    
    7 // 2.0 => 3.0
    ```

14. 数字 随机方法 round()， 该方法一定需要注意：
    [必须需要注意的坑](http://www.runoob.com/w3cnote/python-round-func-note.html)
    在写代码的是尽量少用round方法
    
    Python 所谓的 _奇进偶弃_，因为浮点数的表示在计算机中并不准确，用的时候可能要注意一下。
    ```
    >>> round(10.5)
    10
    >>> round(11.5)
    12
    >>>
    
    print(round(10.4))   >>>> 10
    print(round(10.5))   >>>> 10
    print(round(10.6))   >>>> 11
    print()
    print(round(11.4))   >>>> 11
    print(round(11.5))   >>>> 12
    print(round(11.6))   >>>> 12
    由运行得出结论：
    
    当小数点左边为偶数：小数点右边X<6，舍
    当小数点左边为偶数：小数点右边X>=6，入
    当小数点左边为奇数：小数点右边X<5，舍
    当小数点左边为奇数：小数点右边X>=5，入
    
    ```
    
    ```
    “4舍6入5看齐,奇进偶不进”我觉得并不是因为浮点数在计算机表示的问题。计算机浮点数的表示是 ieee 定义的标准规则，如果 python 中存在，没道理其他语言中不存在。事实上是因为该取舍方法比过去的 "四舍五入" 方法在科学计算中更准确。而国家标准也已经规定使用 “4舍6入5看齐,奇进偶不进” 取代"四舍五入".
    
    从统计学的角度上来讲,如果大量数据无脑的采用四舍五入会造成统计结果偏大。而"奇进偶舍"可以将舍入误差降到最低。
    
    奇进偶舍是一种比较精确比较科学的计数保留法，是一种数字修约规则。
    
    其具体要求如下（以保留两位小数为例）：
    
     （1）要求保留位数的后一位如果是4或者4以下的数字，则舍去， 例如 5.214保留两位小数为5.21。
     （2）如果保留位数的后一位如果是6或者6以上的数字，则进上去， 例如5.216保留两位小数为5.22。
     （3）如果保留位数是保留整数部分或保留一位小数，则要根据保留位来决定奇进偶舍：

    ```
    
15. 数字（Number） 整数比较遇到额一些坑：
    ```
    Python中一切都是对象，对象比较可以用 == 或者 is。
    == 比较的是两个对象的内容是否相等，默认会调用对象的 __eq__() 方法。
    
    is 比较的是两个对象的 id 是否相等，也就是是否是同一个对象，是否指向同一个内存地址。
    
    >>> a = 4
    >>> b = 4
    >>> a == b
    True
    >>> a is b
    True
    >>> a = 256
    >>> b = 256
    >>> a == b
    True
    >>> a is b
    True
    >>> a = 257
    >>> b = 257
    >>> a == b
    True
    >>> a is b
    False
    
    我们看到，前几组比较我们都可以理解显示的结果，但是最后当 a/b 都指向 257 这个整数对象的时候，用 is 比较以后的结果是 False。
    
    这是因为 Python 处于对性能的考虑，内部作了优化，对于整数对象，把一些频繁使用的整数对象缓存起来，保存到一个叫 small_ints 的链表中。
    
    在 Python 整个生命周期中，任何需要引用这些整数对象的地方，都不再重新创建新的整数对象，范围是 [-5,256]。
    
    再看下面这个例子 ：
    
    >>> a = 259
    >>> def foo () :
    ...     b = 259
    ...     c = 259
    ...     print(a is b)
    ...     print(b is c)
    ...
    >>> foo()
    False
    
    True
    
    这是因为 Python 程序都是由代码块构成，代码块作为程序的一个最小基本单位来执行。一个模块文件/一个函数体/一个类/交互式命令中的单行代码都叫做一个代码块。
    
    上面的程序中有两部分代码块，一个是名称 a 所在的代码块，一个是名称 b/c 所在的代码块。Python 的另一个优化的地方就是，如果在同一个代码块中创建的两个整数对象中，
    它们的值相等的话，那么这两个对象引用同一个整数对象。所以Python出于对性能的考虑，但凡是不可变的对象，在同一代码块中，只有值相等的对象就不会重复创建，
    而是直接引用已经存在的对象。不仅整数对象，字符串对象也遵循同样的原则。
    
    ```
    
16. 字符串： 
    - """  """, 三引号是表示多行字符。
    
    - 必须引用如下库 - 计算字符串里面每个字符出现的次数，返回一个hash
      // 需要引入的Counter库
      ```
        from collections import Counter
              
        Var1 = "1116122137143151617181920849510"
        Var2 = "1987262819009787718192084951"
        
        输出结果：
        print(Counter(Var1))
        Counter({'1': 12, '2': 3, '6': 2, '3': 2, '7': 2, '4': 2, '5': 2, '8': 2, '9': 2, '0': 2})
        
        print (Counter(Var2))
        Counter({'1': 5, '9': 5, '8': 5, '7': 4, '2': 3, '0': 3, '6': 1, '4': 1, '5': 1})

      ```
      
17. 序列：序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。
        Python有6个序列的内置类型，但最常见的是列表和元组。
    - 使用del 删除列表元素  
    ```
     list = [1,2,3,4,5,6,7]
     删除一个元素： del list[2]
     删除多个元素： del list[1:3] 
    ```
    - 列表操作符：
    ```
    Python表达式   	                     结果                       	描述
    len([1, 2, 3])      	              3	                        长度
    [1, 2, 3] + [4, 5, 6]	             [1, 2, 3, 4, 5, 6]          组合
    ['Hi!'] * 4                 	     ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 重复
    3 in [1, 2, 3]	                     True	                    元素是否存在于列表中
    for x in [1, 2, 3]: print(x, end=" ")   	1 2 3	            迭代 
    ```
    
    - sorted() 和 sort()方法带有的参数 cmp在python3中已经取消，可以使用key=cmp_to_key取代，
    兼容方法实例： 
    https://www.polarxiong.com/archives/Python3-%E6%89%BE%E5%9B%9Esort-%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84cmp%E5%8F%82%E6%95%B0.html
    http://www.runoob.com/python3/python3-number.html   解释cmp移除问题。

18. <font color="red"> 在使用int 除以 int类型的数据时，返回的结果是 float类型的数据     </font>

19. 生成器
- 通过send 和 next 可以启动生成器函数，但是在使用send启动生成器的时候，send只能接受None参数，如果在启动的时候试图输入别的参数，则会报错。
```
>>> def gen():
...     value = 0
...     while True:
...             receive = yield value
...             if receive == 'e':
...                     break
...             value = 'got: %s' % receive
...
>>> g = gen()
>>> g.send('sdf')
<!-- 错误信息 -->
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't send non-None value to a just-started generator
```
      
20. 迭代器被迭代之后，最后会指向空。

21. 不可变类型的对对象在进行 256KB以下的内存分配时，采用的是深拷贝的方式进行的，当某一个改变的时候，会从新给另外一个对象进行内存分配。
```
在 C 中如果频繁的调用 malloc 与 free 时,是会产生性能问题的.再加上频繁的分配与释放小块的内存会产生内存碎片. Python 在这里主要干的工作有:

　　如果请求分配的内存在1~256字节之间就使用自己的内存管理系统,否则直接使用 malloc.

　　这里还是会调用 malloc 分配内存,但每次会分配一块大小为256k的大块内存.

　　经由内存池登记的内存到最后还是会回收到内存池,并不会调用 C 的 free 释放掉.以便下次使用.对于简单的Python对象，例如数值、字符串，元组（tuple不允许被更改)采用的是复制的方式(深拷贝?)，也就是说当将另一个变量B赋值给变量A时，虽然A和B的内存空间仍然相同，但当A的值发生变化时，会重新给A分配空间，A和B的地址变得不再相同
```

22. 变量的作用域
```
Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。

变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：

L （Local） 局部作用域
E （Enclosing） 闭包函数外的函数中
G （Global） 全局作用域
B （Built-in） 内建作用域

以 L –> E –> G –>B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。

x = int(2.9)  # 内建作用域
 
g_count = 0  # 全局作用域
def outer():
    o_count = 1  # 闭包函数外的函数中
    def inner():
        i_count = 2  # 局部作用域

Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：

>>> if True:
...  msg = 'I am from Runoob'
... 
>>> msg
'I am from Runoob'
>>> 
```

23. global 和 nonlocal关键字 当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。

24. <font color="red"> import 路径搜索 </font>

 一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。

当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？

这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。

这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。

===============================================================

注意当使用from package import item这种形式的时候，对应的item既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。

import语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:ImportError 异常被抛出了。

反之，如果使用形如import item.subitem.subsubitem这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。